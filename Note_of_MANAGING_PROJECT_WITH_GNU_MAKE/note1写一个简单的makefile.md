# 如何写一个简单的 Makefile 笔记

写程序的机制常常是一个简单的流程，写代码、编译为可执行文件、调试结果。尽管把代码转为可执行文件可以看作是一个例行之事，但是如果做的不对那么那个程序员就需要浪费大量时间去追踪问题了。大多数开发者都经历过修改一个函数重新运行代码却发现修改并没有去除错误的沮丧。然后他们会因某些中间过程的错误如无法再次编译源文件、无法链接或者是无法 rebuild 一个 jar 而无法运行程序。另外，随着程序的复杂性增大，多版本程序的开发比如其他平台或是其他版本的库文件等，这些平凡（mundane）任务变得极易出错。

*make* 旨在自动化将代码转可执行文件的平凡（mundane）方面。make 相对脚本的优势在于你可以把你的程序各部分之间的关系指任给 make，它通过这些关系和时间戳精确清楚地知道每次构建程序需要重新编译的部分。使用这些信息，make 可以优化编译过程避免不必要的步骤。

GNU make （以及其它 make 变种）精确地做了以下这些事。它定义了一种语言来描述源代码、中间文件以及可执行文件之间的关系。它还提供了管理可选配置、实现可重用库的规则(specifications)、用户自定义宏来参数话流程等特性。总之，通过提供应用程序部件的线路图和如何把它们恰当组合，make 可以被认为是程序开发过程的中心。

通常，make 的规则 makefile 的文本文件中的。下面是一个构建传统"hello, World" 程序的一个 makefile 文件:

	hello: hello.c
		gcc hello.c -o hello

要构建可执行程序执行，只需在你的终端中运行

	$ make

然后 make 就会构建它的第一个目标

	$ make
	gcc hello.c -o hello

如果一个目标包含了一个命令行参数，那个目标将会被更新。如果没有给定命令行目标，那么文件中的第一个目标被使用，被成为默认目标（default goal）。

典型地，大多数 makefile 的默认目标都是构建一个程序。这通常包括许多步骤。通常源代码不完整而且源代码必须通过一些如 flex 或者 bison 等工具来生成。下一步，源代码被编译为二进制文件（C/C++ 的 .o 文件，Java 的 .class 文件等）。接下来，对于 C/C++ 语言，目标文件被链接器（linker，通常被编译器 compiler 如 gcc 调用）组成可执行程序。

改动任何源文件再调用 make 将会引起部分（通常不是全部的）命令再度执行，这样源代码的变更就可以被包含到可执行文件中。规范文件，即 makefile 文件，描述了源代码、中间文件以及可执行文件之间的关系，所以 make 可以用最小的必要执行代价来更新可执行文件。

使用 make 这一原则的价值在于它可以执行必须的复杂命令来构建应用程序并且在“编辑-编译-调试”环中通过优化这些操作来减少可能需要的时间。另外，make 可以运用在任何一个文件依赖其它文件的情形中，从传统的 C/C++ 到 Java 编程， TEX，数据库管理等等。

## 目标和依赖

本质上，一个 makefile 包含一个规则集合来构建一个应用程序。make 第一个读到的规则是“默认规则”（default rule）。一个规则有三部分：*目标，它的依赖，以及要执行的命令*：

	target: prereq1 prereq2
		commands

	目标：依赖1 依赖2
		执行的命令

*目标*就是要构建输出的文件。
*依赖*就是在成功构建目标之前必须要已经存在的文件。
*命令*就是从依赖构建出目标需要执行的终端命令。

下面是一个编译 C 文件，foo.c 生成目标文件 foo.o 的规则：

	foo.o: foo.c foo.h
		gc -c foo.c

目标文件 foo.o 在冒号的前边；依赖文件 foo.c 和 foo.h 在冒号的后边。
命令另起一行并且开头有一个 Tab 制表符。

当 make 被要求执行一个规则，它开始查找依赖和目标。如果任何依赖还关联有规则，就先尝试更新它们。然后，考虑目标。如果任何依赖时间戳新于目标，那么目标需要执行命令重新构建。每个命令被传送到 shell 在子 shell 中执行。如果任何命令产生一个错误那么构建被终止，make 退出。

## 调用 make
* 项目所有源代码和 make 的规则文件都在单一目录下。
* make 的规则文件叫做 makefile, Makefile, 或者 GNUMakefile
* makefile 在 make 执行时的路径



